Вот **полный перевод на русский язык** документа:

---

# Структура программы libirsample и руководство пользователя

---

## 1. Структура программы

![](./irsample_structure.png)

Как показано на схеме, пример включает следующие модули: **sample**, **camera**, **display**, **temperature** и **cmd**.
Назначение каждого модуля:

* **Модуль sample**:
  После настройки соответствующих параметров в `sample.cpp`, модуль вызывает **camera**, чтобы установить соединение с инфракрасной камерой и начать потоковую передачу изображения.
  Затем создаются четыре потока: **stream**, **display**, **temperature** и **cmd**, каждый из которых обрабатывает соответствующие данные.

* **Модуль camera**:
  Используется для получения данных от инфракрасной камеры.
  Поток **stream** получает исходные инфракрасные кадры и разделяет их на два потока данных — **изображения** (image frame) и **температуры** (temp frame).
  После обработки этих данных соответствующими модулями сигналы возвращаются обратно в поток камеры для следующей итерации.

* **Модуль display**:
  После получения кадров изображения обрабатывает их в соответствии с параметрами `frame_info` — выполняет преобразование формата данных, отражение, зеркалирование, поворот и т. д.
  Затем использует **OpenCV** для отображения результата.

* **Модуль temperature**:
  После получения кадров температуры также выполняет обработку данных (формат, отражение, поворот и т. д.) на основе параметров `frame_info`.

* **Модуль cmd**:
  Отправляет команды на инфракрасную камеру.

---

## 2. Метод компиляции программы

* **Под Windows:**
  В папке `libir_sample` предоставлен полный проект для **Visual Studio 2019**.
  Для работы примера требуются библиотеки **OpenCV** и **pthreadVC2.dll** (уже включены).

* **Под Linux:**
  В `libir_sample` есть файлы `Makefile` и `CMakeLists.txt`.
  Перед компиляцией необходимо удалить каталог `opencv2` (OpenCV устанавливается отдельно).
  Если OpenCV не используется, можно закомментировать строку `#define OPENCV_ENABLE` в `display.h`, а также закомментировать соответствующие секции в `Makefile` или `CMakeLists.txt`.

---

## 3. Руководство пользователя

### 3.1 Подключение камеры

В функции `main()` файла `sample.cpp` камера выбирается вызовом `ir_camera_open()`, после чего получаются параметры камеры `stream_frame_info`.

Затем необходимо вызвать `load_stream_frame_info()` для настройки параметров отображения и измерения температуры: ширина/высота, поворот, зеркалирование, включение псевдоцвета, форматы входных и выходных кадров, выделение памяти и т. д.

```c
stream_frame_info->image_info.width = stream_frame_info->camera_param.width;
stream_frame_info->image_info.height = stream_frame_info->camera_param.height / 2;
stream_frame_info->image_info.rotate_side = LEFT_90D;
stream_frame_info->image_info.mirror_flip_status = STATUS_MIRROR_FLIP;
stream_frame_info->image_info.pseudo_color_status = PSUEDO_COLOR_ON;
stream_frame_info->image_info.img_enhance_status = IMG_ENHANCE_OFF;
stream_frame_info->image_info.input_format = INPUT_FMT_YUV422;
stream_frame_info->image_info.output_format = OUTPUT_FMT_BGR888;

stream_frame_info->temp_info.width = stream_frame_info->camera_param.width;
stream_frame_info->temp_info.height = stream_frame_info->camera_param.height / 2;
stream_frame_info->temp_info.rotate_side = NO_ROTATE;
stream_frame_info->temp_info.mirror_flip_status = STATUS_NO_MIRROR_FLIP;
stream_frame_info->image_byte_size = stream_frame_info->image_info.width * stream_frame_info->image_info.height * 2;
stream_frame_info->temp_byte_size = stream_frame_info->temp_info.width * stream_frame_info->temp_info.height * 2;
```

**Основные поля структуры `StreamFrameInfo_t`:**

* `width` / `height` — размеры кадра, задаются вручную.
* `byte_size` — размер кадра в байтах. Для изображений вычисляется автоматически.
* `rotate_side`, `mirror_flip_status` — параметры поворота и зеркалирования, задаются вручную.
* `input_format`, `output_format` — форматы входных/выходных данных (например, Y14 → RGB888).
* `pseudo_color_status` — флаг включения псевдоцвета.
* `img_enhance_status` — включение алгоритма растяжения контраста.
* `image_byte_size` / `temp_byte_size` — размеры буферов данных.

---

### 3.2 Управление потоковой передачей

После открытия устройства и заполнения параметров можно вызвать `ir_camera_stream_on()`
или `ir_camera_stream_on_with_callback()` (если используется пользовательская функция обратного вызова).

Во время отображения вызывается `display_one_frame()`, которая ждёт сигнал нового кадра и затем вызывает `display_image_process()` для преобразования формата, применения псевдоцвета и вращения, после чего показывает результат через `cv::imshow()`.

---

### 3.3 Отправка команд

Функция `cmd_function()` в `cmd.cpp` позволяет отправлять команды камере, вводя числа с клавиатуры.
Ввод разных чисел вызывает разные функции через `command_sel(cmd)`.

---

### 3.4 Измерение температуры

Функция `temperature_function()` в `temperature.cpp` каждые 25 кадров выполняет измерение температуры в одном из трёх режимов: **точечный**, **линейный** или **площадной**.

```c
if (timer % 25 == 0)
{
    line_temp_demo((uint16_t*)stream_frame_info->temp_frame, temp_res);
}
```

> ⚠️ При работе в многопоточном режиме рекомендуется использовать **mutex**, чтобы избежать конфликтов при отправке команд.

---

### 3.5 Завершение работы программы

В конце программы вызываются:

* `destroy_pthread_sem()` — завершает сигнальные потоки,
* `uvc_camera_close()` — закрывает соединение с камерой.

---

### 3.6 Обновление прошивки

В `cmd.cpp` используется функция `update_fw_cmd()` для обновления микропрограммы камеры.
После указания пути к файлу выполняются следующие шаги:

1. Проверка текущего режима устройства (**ROM / Cache**) и переключение в **ROM mode**.
2. Проверка состояния SPI и сброс.
3. Стирание области flash-памяти (256 КБ = 64 сектора по 4 КБ).
4. Запись нового файла прошивки и проверка совпадения данных.
5. Запись метки (cache tag), подтверждающей успешную запись.
6. Перезапуск устройства — камера возвращается в обычный режим (**Cache Mode**).

После этого обновление завершено.

---

### 3.7 Вторичная калибровка измерения температуры

В `cmd.cpp`, в кейсе **16**, функция `read_nuc_parameter()` считывает параметры NUC,
а `calculate_org_env_cali_parameter()` вычисляет коэффициенты температурной коррекции.

В кейсе **17** функция `calculate_new_env_cali_parameter()` пересчитывает коэффициенты с учётом новых параметров среды (эмиссивность, температура атмосферы, расстояние и влажность).
Функция `tpd_get_point_temp_info()` считывает исходную температуру точки, а `temp_calc_with_new_env_calibration()` выполняет пересчёт и выдаёт скорректированное значение.

---

### 3.8 Функции автоматического усиления и защиты от пересвета

В `camera.cpp` (функция `stream_function`) реализованы функции **предотвращения пересвета** и **автоматического переключения усиления**.
Обе функции используют данные температурного кадра (`stream_frame_info->temp_frame`).

```c
avoid_overexposure((uint16_t*)stream_frame_info->temp_frame, &stream_frame_info->temp_info, 10 * fps);
auto_gain_switch((uint16_t*)stream_frame_info->temp_frame, &stream_frame_info->temp_info, &auto_gain_switch_info);
```

---

Хочешь, чтобы я оформил этот перевод в виде профессионального **PDF-руководства** (с форматированием, разделами и оглавлением)? Это удобно для включения в SDK-документацию.
